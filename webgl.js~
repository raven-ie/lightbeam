window.onload = function() {
	var renderer = null,
		stats = new Stats();
	stats.setMode(0);
	document.body.appendChild(stats.domElement);
	if((renderer = lightbeam.createRenderer("viewport"))) {
		var vertexShader = "varying float lifePercentage;" +
						   "void main() {" +
					       "	vec4 eyePos = modelViewMatrix * vec4(particleData.x, particleData.y, particleData.z, 1.0);" +
						   "	vec4 projCorner = projectionMatrix * vec4(0.5 * particleSize, 0.5 * particleSize, eyePos.z, eyePos.w);" +
						   "	gl_Position = projectionMatrix * eyePos;" +
						   "	gl_PointSize = screenWidth * projCorner.x / projCorner.w;" +
						   "	lifePercentage = particleData.w;" +
						   "}",
			fragmentShader = "varying float lifePercentage;" +
							 "void main() {" +
							 "	vec4 textureColor = texture2D(colorMap, gl_PointCoord);" +
							 "	if(textureColor.a < 0.25) discard;" +
							 "	gl_FragColor = vec4(textureColor.rgb, textureColor.a * lifePercentage);" +
							 "}";
		renderer.createShader("shader-particles", vertexShader, fragmentShader, lightbeam.shader.type.particles);
		vertexShader = "varying vec2 texcoord;" +
					   "varying vec3 position;" +
					   "varying vec3 transformedNormal;" +
					   "void main(void) {" +
					   "	gl_Position = projectionMatrix * modelViewMatrix * vec4(vertexPosition, 1.0);" +
					   "	texcoord = vertexTexcoord;" +
					   "	position = vec3(modelViewMatrix * vec4(vertexPosition, 1.0)).xyz;" +
					   "	transformedNormal = normalize(normalMatrix * vertexNormal);" +
					   "}",
		fragmentShader = "varying vec2 texcoord;" +
						 "varying vec3 position;" +
						 "varying vec3 transformedNormal;" +
						 "void main(void) {" +
						 "	float directionalLight = max(dot(transformedNormal, lightDirection), 0.0);" +
						 "	vec3 lightWeight = materialAmbient * lightAmbient + materialDiffuse * lightDiffuse * directionalLight;" +
						 "	vec3 negateVertex = normalize(-position.xyz);" +
						 "	vec3 reflection = reflect(-lightDirection, transformedNormal);" +
						 "	float specularWeight = pow(max(dot(reflection, negateVertex), 0.0), materialShininess);" +
						 "	lightWeight += materialSpecular * lightSpecular * specularWeight;" +
						 "	vec4 textureColor = texture2D(colorMap, vec2(texcoord.s, texcoord.t));" +
						 "	gl_FragColor = vec4(textureColor.rgb * lightWeight, textureColor.a);" +
						 "}";
		renderer.createShader("shader-complex", vertexShader, fragmentShader, lightbeam.shader.type.complex);
		var camera = renderer.createCameraThirdPerson("camera", null, true);
		camera.distance.back = 40.0;
		camera.distance.top = 3.0;
		var cube_one = renderer.createEntity("cube-one", {
			"shader"   : "shader-complex",
			"model"    : "models/tree/tree.mesh",
			"position" : [50.0, 0.0, 0.0]
		});
		var cube_two = renderer.createEntity("cube-two", {
			"shader"   : "shader-complex",
			"model"    : "models/scene/scene.mesh",
			"onCreate" : function() {
				this.nodes["Icosphere"].rotation[1] = 1.0;
				this.nodes["Icosphere"].position[0] = 2.5;
			}
		});
		var objects = [cube_one, cube_two];
		var r = 25.0;
		var sparkles = {
			"count"    : 10000,
			"size"     : 0.5,
			"shader"   : "shader-particles",
			"texture"  : "particles/spark.png",
			"onUpdate" : function() {
				for(var i in this.particles) {
					var particle = this.particles[i];
					if(particle.timeRemaining < 0.0) {
						particle.timeRemaining = Math.random() * 40.0 + 10.0;
						particle.timeAll = particle.timeRemaining;
						particle.position = [Math.random() * (r - (-r)) + (-r),
											 25.0,
											 Math.random() * (r - (-r)) + (-r)];
					}
					particle.position[1] -= 1.0 * renderer.time.delta;
					particle.timeRemaining -= renderer.time.delta;
				}
			}
		};
		var emitter = renderer.createEmitter("emitter", sparkles);
		document.getElementById("viewport").onmousedown = function(event) {
			var w = this.width, h = this.height, mouseCoords = [];
			//get mouse x, y coords relative to renderer viewport
			if(event.offsetX !== undefined) {
				mouseCoords[0] =  (event.offsetX - w / 2) / (w / 2);
				mouseCoords[1] = -(event.offsetY - h / 2) / (h / 2);
			}
			else {
				var x = event.pageX - this.offsetLeft,
					y = event.pageY - this.offsetTop;
				mouseCoords[0] =  (x - w / 2) / (w / 2);
				mouseCoords[1] = -(y - h / 2) / (h / 2);
			}
			var intersection = lightbeam.collisions.ray(mouseCoords, renderer.matrix, objects);
			if(intersection) {
				//we have here an intersection
				if(intersection.model == "models/tree/tree.mesh") {
					intersection.model = "models/scene/scene.mesh";
				}
				else {
					intersection.model = "models/tree/tree.mesh";
				}
			}
		};
		renderer.frame();
		renderer.onUpdate = function() {
			stats.update();
			if(lightbeam.collisions.collider(cube_one, objects)) {
				//there is collision between tree entity and certain element of the array
				//emitter.visible = false;
			}
			else {
				//emitter.visible = true;
			}
			cube_one.position[0] -= 2.5 * renderer.time.delta;
		};
	}
};
